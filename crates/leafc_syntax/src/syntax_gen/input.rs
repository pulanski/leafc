//! Defines **inputs** for the **code generation process** (e.g. `SyntaxKinds`).
//!
//! The module takes a **declarative** approach to defining the **syntax** of
//! the language, and then uses this to **procedurally generate** many of the
//! **language constructs** used throughout the compiler, particularly within
//! the parser.

/// The **effective input** for the **code generation process**.
///
/// Specifies all the _different kinds_ of **syntax nodes** and **tokens** in
/// the **language**.
/// The [`SyntaxKind`][crate::ast::generated::syntax_kind::SyntaxKind] enum is
/// generated from this.
pub(crate) struct SyntaxKinds<'a> {
    pub(crate) punct: &'a [(&'a str, &'a str)],
    pub(crate) keywords: &'a [&'a str],
    pub(crate) contextual_keywords: &'a [&'a str],
    pub(crate) literals: &'a [&'a str],
    pub(crate) tokens: &'a [&'a str],
    // pub(crate) tokens: &'a [(&'a str, &'a str)],
    pub(crate) nodes: &'a [&'a str],
}

pub(crate) const KINDS_SRC: SyntaxKinds<'_> = SyntaxKinds {
    punct: &[
        (":=", "DEFINE"),
        ("+", "PLUS"),
        ("-", "MINUS"),
        ("*", "STAR"),
        ("/", "SLASH"),
        ("%", "PERCENT"),
        ("^", "CARET"),
        ("!", "BANG"),
        ("&", "AMPERSAND"),
        ("|", "PIPE"),
        ("&&", "DOUBLE_AMPERSAND"),
        ("||", "DOUBLE_PIPE"),
        ("<<", "SHL"),
        (">>", "SHR"),
        ("+=", "PLUS_EQ"),
        ("-=", "MINUS_EQ"),
        ("*=", "STAR_EQ"),
        ("/=", "SLASH_EQ"),
        ("%=", "PERCENT_EQ"),
        ("^=", "CARET_EQ"),
        ("&=", "AMPERSAND_EQ"),
        ("|=", "PIPE_EQ"),
        ("<<=", "SHL_EQ"),
        (">>=", "SHR_EQ"),
        ("=", "EQ"),
        ("==", "EQEQ"),
        ("!=", "NE"),
        (">", "GT"),
        ("<", "LT"),
        (">=", "GE"),
        ("<=", "LE"),
        ("@", "AT"),
        ("_", "UNDERSCORE"),
        (".", "DOT"),
        ("..", "DOTDOT"),
        ("..=", "DOTDOTEQ"),
        (",", "COMMA"),
        (";", "SEMICOLON"),
        (":", "COLON"),
        ("::", "PATHSEP"),
        ("->", "RARROW"),
        ("=>", "FATARROW"),
        ("#", "HASH"),
        ("$", "DOLLAR"),
        ("?", "QMARK"),
        ("~", "TILDE"),
        ("[", "L_BRACKET"),
        ("]", "R_BRACKET"),
        ("(", "L_PAREN"),
        (")", "R_PAREN"),
        ("{", "L_BRACE"),
        ("}", "R_BRACE"),
        // ("⁽", "L_PAREN_SUPERSCRIPT"),
        // ("⁾", "R_PAREN_SUPERSCRIPT"),
        ("<-", "L_ARROW"),
        ("**", "DOUBLE_STAR"),
    ],
    keywords: &[
        "abstract",
        "async",
        "await",
        "extern",
        "final",
        "is",
        "and",
        "as",
        "break",
        "const",
        "continue",
        "do",
        "dyn",
        "else",
        "enum",
        "false",
        "fn",
        "for",
        "if",
        "impl",
        "import",
        "in",
        "let",
        "loop",
        "match",
        "missing",
        "mod",
        "move",
        "mut",
        "not",
        "or",
        "package",
        "pub",
        "return",
        "self_type",
        "self_value",
        "static",
        "struct",
        "super",
        "trait",
        "true",
        "type",
        "unsafe",
        "use",
        "where",
        "while",
        "yield",
    ],
    // contextual_keywords: &["auto", "default", "existential", "union", "raw", "macro_rules",
    // "yeet"], // TODO: update this
    contextual_keywords: &[], // TODO: update this
    literals: &["RUNE", "STRING", "RAW_STRING", "INTEGER", "FLOAT", "LIFETIME"],
    tokens: &[
        "WHITESPACE",
        "ERROR",
        "IDENTIFIER",
        "COMMENT",
        "DOC_COMMENT",
        // ("WHITESPACE", include_str!("../../../../docs/src/chapter_1/tokens/WHITESPACE.md")), //
        // TODO: maybe this in future
    ],
    nodes: &[
        "SOURCE_FILE",
        // "STRUCT",
        // "UNION",
        // "ENUM",
        // "FN",
        // "RET_TYPE",
        // "EXTERN_CRATE",
        // "MODULE",
        // "USE",
        // "STATIC",
        // "CONST",
        // "TRAIT",
        // "IMPL",
        // "TYPE_ALIAS",
        // "MACRO_CALL",
        // "MACRO_RULES",
        // "MACRO_ARM",
        "TOKEN_TREE",
        // "MACRO_DEF",
        // "PAREN_TYPE",
        // "TUPLE_TYPE",
        // "MACRO_TYPE",
        // "NEVER_TYPE",
        // "PATH_TYPE",
        // "PTR_TYPE",
        // "ARRAY_TYPE",
        // "SLICE_TYPE",
        // "REF_TYPE",
        // "INFER_TYPE",
        // "FN_PTR_TYPE",
        // "FOR_TYPE",
        // "IMPL_TRAIT_TYPE",
        // "DYN_TRAIT_TYPE",
        // "OR_PAT",
        // "PAREN_PAT",
        // "REF_PAT",
        // "BOX_PAT",
        // "IDENT_PAT",
        // "WILDCARD_PAT",
        // "REST_PAT",
        // "PATH_PAT",
        // "RECORD_PAT",
        // "RECORD_PAT_FIELD_LIST",
        // "RECORD_PAT_FIELD",
        // "TUPLE_STRUCT_PAT",
        // "TUPLE_PAT",
        // "SLICE_PAT",
        // "RANGE_PAT",
        // "LITERAL_PAT",
        // "MACRO_PAT",
        // "CONST_BLOCK_PAT",
        // // atoms
        // "TUPLE_EXPR",
        // "ARRAY_EXPR",
        // "PAREN_EXPR",
        // "PATH_EXPR",
        // "CLOSURE_EXPR",
        // "IF_EXPR",
        // "WHILE_EXPR",
        // "LOOP_EXPR",
        // "FOR_EXPR",
        // "CONTINUE_EXPR",
        // "BREAK_EXPR",
        // "LABEL",
        // "BLOCK_EXPR",
        // "STMT_LIST",
        // "RETURN_EXPR",
        // "YIELD_EXPR",
        // "YEET_EXPR",
        // "LET_EXPR",
        // "UNDERSCORE_EXPR",
        // "MACRO_EXPR",
        // "MATCH_EXPR",
        // "MATCH_ARM_LIST",
        // "MATCH_ARM",
        // "MATCH_GUARD",
        // "RECORD_EXPR",
        // "RECORD_EXPR_FIELD_LIST",
        // "RECORD_EXPR_FIELD",
        // "BOX_EXPR",
        // // postfix
        // "CALL_EXPR",
        // "INDEX_EXPR",
        // "METHOD_CALL_EXPR",
        // "FIELD_EXPR",
        // "AWAIT_EXPR",
        // "TRY_EXPR",
        // "CAST_EXPR",
        // // unary
        // "REF_EXPR",
        // "PREFIX_EXPR",
        // "RANGE_EXPR", // just weird
        // "BIN_EXPR",
        // "EXTERN_BLOCK",
        // "EXTERN_ITEM_LIST",
        // "VARIANT",
        // "RECORD_FIELD_LIST",
        // "RECORD_FIELD",
        // "TUPLE_FIELD_LIST",
        // "TUPLE_FIELD",
        // "VARIANT_LIST",
        // "ITEM_LIST",
        // "ASSOC_ITEM_LIST",
        "ATTR",
        "META",
        // "USE_TREE",
        // "USE_TREE_LIST",
        "PATH",
        "PATH_SEGMENT",
        // "LITERAL",
        // "RENAME",
        // "VISIBILITY",
        // "WHERE_CLAUSE",
        // "WHERE_PRED",
        // "ABI",
        "NAME",
        "NAME_REF",
        // "LET_STMT",
        // "LET_ELSE",
        // "EXPR_STMT",
        // "GENERIC_PARAM_LIST",
        // "GENERIC_PARAM",
        // "LIFETIME_PARAM",
        // "TYPE_PARAM",
        // "CONST_PARAM",
        // "GENERIC_ARG_LIST",
        // "LIFETIME",
        // "LIFETIME_ARG",
        // "TYPE_ARG",
        // "ASSOC_TYPE_ARG",
        // "CONST_ARG",
        // "PARAM_LIST",
        // "PARAM",
        // "SELF_PARAM",
        // "ARG_LIST",
        // "TYPE_BOUND",
        // "TYPE_BOUND_LIST",
        // // macro related
        // "MACRO_ITEMS",
        // "MACRO_STMTS",
    ],
};

#[derive(Default, Debug)]
pub(crate) struct AstSrc {
    pub(crate) tokens: Vec<String>,
    pub(crate) nodes: Vec<AstNodeSrc>,
    pub(crate) enums: Vec<AstEnumSrc>,
}

#[derive(Debug)]
pub(crate) struct AstNodeSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) fields: Vec<Field>,
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Field {
    Token(String),
    Node { name: String, ty: String, cardinality: Cardinality },
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Cardinality {
    Optional,
    Many,
}

#[derive(Debug)]
pub(crate) struct AstEnumSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) variants: Vec<String>,
}
