//! Generated by `syntax_gen`, do not edit by hand.
//!
//! To regenerate this file, run `cargo xtask syntaxgen` or `cargo test -p
//! leafc_syntax`.
//!
//! Source files relevant to syntax generation include
//! crates/leafc_syntax/src/syntaxgen/syntax_kind.rs. This module contains the
//! definition of the `SyntaxKind` enum, which is used to represent the
//! different kinds of syntax nodes in the tree. This includes tokens (i.e. leaf
//! nodes) as well as non-terminal nodes (i.e. internal nodes).

#![allow(bad_style, missing_docs, unreachable_pub)]
#[allow(clippy::manual_non_exhaustive, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, FromPrimitive, ToPrimitive)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    ///Literals (e.g. RUNE, STRING, RAW_STRING, INTEGER, FLOAT, LIFETIME)
    RUNE,
    STRING,
    RAW_STRING,
    INTEGER,
    FLOAT,
    LIFETIME,
    ///Tokens (e.g. WHITESPACE, ERROR, IDENTIFIER, COMMENT, DOC_COMMENT)
    WHITESPACE,
    ERROR,
    IDENTIFIER,
    COMMENT,
    DOC_COMMENT,
    ///Keywords (e.g. AS, BREAK, CONST, ENUM, EXTERN, FALSE, FN, IF, IMPL, IN,
    /// LET, LOOP, MATCH, MOD, MOVE, MUT, PUB, REF, RETURN, SELF, STATIC,
    /// STRUCT, SUPER, TRUE, TRAIT, TYPE, UNSAFE, USE, WHERE, WHILE)
    ABSTRACT_KW,
    ASYNC_KW,
    AWAIT_KW,
    EXTERN_KW,
    FINAL_KW,
    IS_KW,
    AND_KW,
    AS_KW,
    BREAK_KW,
    CONST_KW,
    CONTINUE_KW,
    DO_KW,
    DYN_KW,
    ELSE_KW,
    ENUM_KW,
    FALSE_KW,
    FN_KW,
    FOR_KW,
    IF_KW,
    IMPL_KW,
    IMPORT_KW,
    IN_KW,
    LET_KW,
    LOOP_KW,
    MATCH_KW,
    MISSING_KW,
    MOD_KW,
    MOVE_KW,
    MUT_KW,
    NOT_KW,
    OR_KW,
    PACKAGE_KW,
    PUB_KW,
    RETURN_KW,
    SELF_TYPE_KW,
    SELF_VALUE_KW,
    STATIC_KW,
    STRUCT_KW,
    SUPER_KW,
    TRAIT_KW,
    TRUE_KW,
    TYPE_KW,
    UNSAFE_KW,
    USE_KW,
    WHERE_KW,
    WHILE_KW,
    YIELD_KW,
    ///Punctuation (e.g. DOT, COMMA, SEMICOLON, COLON, COLONCOLON, EQ, EQEQ,
    /// FAT_ARROW, LARROW, RARROW, DOLLAR, LPAREN, RPAREN, LBRACK, RBRACK,
    /// LBRACE, RBRACE)
    DEFINE,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    PERCENT,
    CARET,
    BANG,
    AMPERSAND,
    PIPE,
    DOUBLE_AMPERSAND,
    DOUBLE_PIPE,
    SHL,
    SHR,
    PLUS_EQ,
    MINUS_EQ,
    STAR_EQ,
    SLASH_EQ,
    PERCENT_EQ,
    CARET_EQ,
    AMPERSAND_EQ,
    PIPE_EQ,
    SHL_EQ,
    SHR_EQ,
    EQ,
    EQEQ,
    NE,
    GT,
    LT,
    GE,
    LE,
    AT,
    UNDERSCORE,
    DOT,
    DOTDOT,
    DOTDOTEQ,
    COMMA,
    SEMICOLON,
    COLON,
    PATHSEP,
    RARROW,
    FATARROW,
    HASH,
    DOLLAR,
    QMARK,
    TILDE,
    L_BRACKET,
    R_BRACKET,
    L_PAREN,
    R_PAREN,
    L_BRACE,
    R_BRACE,
    L_ARROW,
    DOUBLE_STAR,
    ///Nodes (e.g. VarDecl, etc.)
    SOURCE_FILE,
    MODULE,
    USE,
    TOKEN_TREE,
    PAREN_TYPE,
    NEVER_TYPE,
    PATH_TYPE,
    FIELD_EXPR,
    REF_EXPR,
    RECORD_FIELD_LIST,
    RECORD_FIELD,
    TUPLE_FIELD_LIST,
    TUPLE_FIELD,
    ITEM_LIST,
    ATTR,
    META,
    USE_TREE,
    USE_TREE_LIST,
    PATH,
    PATH_SEGMENT,
    RENAME,
    VISIBILITY,
    NAME,
    NAME_REF,
    EXPR_STMT,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
use leafc_lexer::TokenKind;
use num_derive::{
    FromPrimitive,
    ToPrimitive,
};
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            ABSTRACT_KW |
                ASYNC_KW |
                AWAIT_KW |
                EXTERN_KW |
                FINAL_KW |
                IS_KW |
                AND_KW |
                AS_KW |
                BREAK_KW |
                CONST_KW |
                CONTINUE_KW |
                DO_KW |
                DYN_KW |
                ELSE_KW |
                ENUM_KW |
                FALSE_KW |
                FN_KW |
                FOR_KW |
                IF_KW |
                IMPL_KW |
                IMPORT_KW |
                IN_KW |
                LET_KW |
                LOOP_KW |
                MATCH_KW |
                MISSING_KW |
                MOD_KW |
                MOVE_KW |
                MUT_KW |
                NOT_KW |
                OR_KW |
                PACKAGE_KW |
                PUB_KW |
                RETURN_KW |
                SELF_TYPE_KW |
                SELF_VALUE_KW |
                STATIC_KW |
                STRUCT_KW |
                SUPER_KW |
                TRAIT_KW |
                TRUE_KW |
                TYPE_KW |
                UNSAFE_KW |
                USE_KW |
                WHERE_KW |
                WHILE_KW |
                YIELD_KW
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            DEFINE |
                PLUS |
                MINUS |
                STAR |
                SLASH |
                PERCENT |
                CARET |
                BANG |
                AMPERSAND |
                PIPE |
                DOUBLE_AMPERSAND |
                DOUBLE_PIPE |
                SHL |
                SHR |
                PLUS_EQ |
                MINUS_EQ |
                STAR_EQ |
                SLASH_EQ |
                PERCENT_EQ |
                CARET_EQ |
                AMPERSAND_EQ |
                PIPE_EQ |
                SHL_EQ |
                SHR_EQ |
                EQ |
                EQEQ |
                NE |
                GT |
                LT |
                GE |
                LE |
                AT |
                UNDERSCORE |
                DOT |
                DOTDOT |
                DOTDOTEQ |
                COMMA |
                SEMICOLON |
                COLON |
                PATHSEP |
                RARROW |
                FATARROW |
                HASH |
                DOLLAR |
                QMARK |
                TILDE |
                L_BRACKET |
                R_BRACKET |
                L_PAREN |
                R_PAREN |
                L_BRACE |
                R_BRACE |
                L_ARROW |
                DOUBLE_STAR
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(self, RUNE | STRING | RAW_STRING | INTEGER | FLOAT | LIFETIME)
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "abstract" => ABSTRACT_KW,
            "async" => ASYNC_KW,
            "await" => AWAIT_KW,
            "extern" => EXTERN_KW,
            "final" => FINAL_KW,
            "is" => IS_KW,
            "and" => AND_KW,
            "as" => AS_KW,
            "break" => BREAK_KW,
            "const" => CONST_KW,
            "continue" => CONTINUE_KW,
            "do" => DO_KW,
            "dyn" => DYN_KW,
            "else" => ELSE_KW,
            "enum" => ENUM_KW,
            "false" => FALSE_KW,
            "fn" => FN_KW,
            "for" => FOR_KW,
            "if" => IF_KW,
            "impl" => IMPL_KW,
            "import" => IMPORT_KW,
            "in" => IN_KW,
            "let" => LET_KW,
            "loop" => LOOP_KW,
            "match" => MATCH_KW,
            "missing" => MISSING_KW,
            "mod" => MOD_KW,
            "move" => MOVE_KW,
            "mut" => MUT_KW,
            "not" => NOT_KW,
            "or" => OR_KW,
            "package" => PACKAGE_KW,
            "pub" => PUB_KW,
            "return" => RETURN_KW,
            "self_type" => SELF_TYPE_KW,
            "self_value" => SELF_VALUE_KW,
            "static" => STATIC_KW,
            "struct" => STRUCT_KW,
            "super" => SUPER_KW,
            "trait" => TRAIT_KW,
            "true" => TRUE_KW,
            "type" => TYPE_KW,
            "unsafe" => UNSAFE_KW,
            "use" => USE_KW,
            "where" => WHERE_KW,
            "while" => WHILE_KW,
            "yield" => YIELD_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '+' => PLUS,
            '-' => MINUS,
            '*' => STAR,
            '/' => SLASH,
            '%' => PERCENT,
            '^' => CARET,
            '!' => BANG,
            '&' => AMPERSAND,
            '|' => PIPE,
            '=' => EQ,
            '>' => GT,
            '<' => LT,
            '@' => AT,
            '_' => UNDERSCORE,
            '.' => DOT,
            ',' => COMMA,
            ';' => SEMICOLON,
            ':' => COLON,
            '#' => HASH,
            '$' => DOLLAR,
            '?' => QMARK,
            '~' => TILDE,
            '[' => L_BRACKET,
            ']' => R_BRACKET,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_BRACE,
            '}' => R_BRACE,
            _ => return None,
        };
        Some(tok)
    }
}
///Converts a `TokenKind` generated by the **Lexer** to a into a `SyntaxKind`
/// for use via the parser and other tools.
impl From<TokenKind> for SyntaxKind {
    fn from(kind: TokenKind) -> SyntaxKind {
        match kind {
            TokenKind::DEFINE => DEFINE,
            TokenKind::PLUS => PLUS,
            TokenKind::MINUS => MINUS,
            TokenKind::STAR => STAR,
            TokenKind::SLASH => SLASH,
            TokenKind::PERCENT => PERCENT,
            TokenKind::CARET => CARET,
            TokenKind::BANG => BANG,
            TokenKind::AMPERSAND => AMPERSAND,
            TokenKind::PIPE => PIPE,
            TokenKind::DOUBLE_AMPERSAND => DOUBLE_AMPERSAND,
            TokenKind::DOUBLE_PIPE => DOUBLE_PIPE,
            TokenKind::SHL => SHL,
            TokenKind::SHR => SHR,
            TokenKind::PLUS_EQ => PLUS_EQ,
            TokenKind::MINUS_EQ => MINUS_EQ,
            TokenKind::STAR_EQ => STAR_EQ,
            TokenKind::SLASH_EQ => SLASH_EQ,
            TokenKind::PERCENT_EQ => PERCENT_EQ,
            TokenKind::CARET_EQ => CARET_EQ,
            TokenKind::AMPERSAND_EQ => AMPERSAND_EQ,
            TokenKind::PIPE_EQ => PIPE_EQ,
            TokenKind::SHL_EQ => SHL_EQ,
            TokenKind::SHR_EQ => SHR_EQ,
            TokenKind::EQ => EQ,
            TokenKind::EQEQ => EQEQ,
            TokenKind::NE => NE,
            TokenKind::GT => GT,
            TokenKind::LT => LT,
            TokenKind::GE => GE,
            TokenKind::LE => LE,
            TokenKind::AT => AT,
            TokenKind::UNDERSCORE => UNDERSCORE,
            TokenKind::DOT => DOT,
            TokenKind::DOTDOT => DOTDOT,
            TokenKind::DOTDOTEQ => DOTDOTEQ,
            TokenKind::COMMA => COMMA,
            TokenKind::SEMICOLON => SEMICOLON,
            TokenKind::COLON => COLON,
            TokenKind::PATHSEP => PATHSEP,
            TokenKind::RARROW => RARROW,
            TokenKind::FATARROW => FATARROW,
            TokenKind::HASH => HASH,
            TokenKind::DOLLAR => DOLLAR,
            TokenKind::QMARK => QMARK,
            TokenKind::TILDE => TILDE,
            TokenKind::L_BRACKET => L_BRACKET,
            TokenKind::R_BRACKET => R_BRACKET,
            TokenKind::L_PAREN => L_PAREN,
            TokenKind::R_PAREN => R_PAREN,
            TokenKind::L_BRACE => L_BRACE,
            TokenKind::R_BRACE => R_BRACE,
            TokenKind::L_ARROW => L_ARROW,
            TokenKind::DOUBLE_STAR => DOUBLE_STAR,
            TokenKind::ABSTRACT_KW => ABSTRACT_KW,
            TokenKind::ASYNC_KW => ASYNC_KW,
            TokenKind::AWAIT_KW => AWAIT_KW,
            TokenKind::EXTERN_KW => EXTERN_KW,
            TokenKind::FINAL_KW => FINAL_KW,
            TokenKind::IS_KW => IS_KW,
            TokenKind::AND_KW => AND_KW,
            TokenKind::AS_KW => AS_KW,
            TokenKind::BREAK_KW => BREAK_KW,
            TokenKind::CONST_KW => CONST_KW,
            TokenKind::CONTINUE_KW => CONTINUE_KW,
            TokenKind::DO_KW => DO_KW,
            TokenKind::DYN_KW => DYN_KW,
            TokenKind::ELSE_KW => ELSE_KW,
            TokenKind::ENUM_KW => ENUM_KW,
            TokenKind::FALSE_KW => FALSE_KW,
            TokenKind::FN_KW => FN_KW,
            TokenKind::FOR_KW => FOR_KW,
            TokenKind::IF_KW => IF_KW,
            TokenKind::IMPL_KW => IMPL_KW,
            TokenKind::IMPORT_KW => IMPORT_KW,
            TokenKind::IN_KW => IN_KW,
            TokenKind::LET_KW => LET_KW,
            TokenKind::LOOP_KW => LOOP_KW,
            TokenKind::MATCH_KW => MATCH_KW,
            TokenKind::MISSING_KW => MISSING_KW,
            TokenKind::MOD_KW => MOD_KW,
            TokenKind::MOVE_KW => MOVE_KW,
            TokenKind::MUT_KW => MUT_KW,
            TokenKind::NOT_KW => NOT_KW,
            TokenKind::OR_KW => OR_KW,
            TokenKind::PACKAGE_KW => PACKAGE_KW,
            TokenKind::PUB_KW => PUB_KW,
            TokenKind::RETURN_KW => RETURN_KW,
            TokenKind::SELF_TYPE_KW => SELF_TYPE_KW,
            TokenKind::SELF_VALUE_KW => SELF_VALUE_KW,
            TokenKind::STATIC_KW => STATIC_KW,
            TokenKind::STRUCT_KW => STRUCT_KW,
            TokenKind::SUPER_KW => SUPER_KW,
            TokenKind::TRAIT_KW => TRAIT_KW,
            TokenKind::TRUE_KW => TRUE_KW,
            TokenKind::TYPE_KW => TYPE_KW,
            TokenKind::UNSAFE_KW => UNSAFE_KW,
            TokenKind::USE_KW => USE_KW,
            TokenKind::WHERE_KW => WHERE_KW,
            TokenKind::WHILE_KW => WHILE_KW,
            TokenKind::YIELD_KW => YIELD_KW,
            _ => unreachable!(),
        }
    }
}
#[macro_export]
macro_rules ! T { [:=] => { $ crate :: SyntaxKind :: DEFINE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [&] => { $ crate :: SyntaxKind :: AMPERSAND } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [&&] => { $ crate :: SyntaxKind :: DOUBLE_AMPERSAND } ; [||] => { $ crate :: SyntaxKind :: DOUBLE_PIPE } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [+=] => { $ crate :: SyntaxKind :: PLUS_EQ } ; [-=] => { $ crate :: SyntaxKind :: MINUS_EQ } ; [*=] => { $ crate :: SyntaxKind :: STAR_EQ } ; [/=] => { $ crate :: SyntaxKind :: SLASH_EQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENT_EQ } ; [^=] => { $ crate :: SyntaxKind :: CARET_EQ } ; [&=] => { $ crate :: SyntaxKind :: AMPERSAND_EQ } ; [|=] => { $ crate :: SyntaxKind :: PIPE_EQ } ; [<<=] => { $ crate :: SyntaxKind :: SHL_EQ } ; [>>=] => { $ crate :: SyntaxKind :: SHR_EQ } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQEQ } ; [!=] => { $ crate :: SyntaxKind :: NE } ; [>] => { $ crate :: SyntaxKind :: GT } ; [<] => { $ crate :: SyntaxKind :: LT } ; [>=] => { $ crate :: SyntaxKind :: GE } ; [<=] => { $ crate :: SyntaxKind :: LE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOTDOT } ; [..=] => { $ crate :: SyntaxKind :: DOTDOTEQ } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: PATHSEP } ; [->] => { $ crate :: SyntaxKind :: RARROW } ; [=>] => { $ crate :: SyntaxKind :: FATARROW } ; [#] => { $ crate :: SyntaxKind :: HASH } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [?] => { $ crate :: SyntaxKind :: QMARK } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; ['['] => { $ crate :: SyntaxKind :: L_BRACKET } ; [']'] => { $ crate :: SyntaxKind :: R_BRACKET } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_BRACE } ; ['}'] => { $ crate :: SyntaxKind :: R_BRACE } ; [<-] => { $ crate :: SyntaxKind :: L_ARROW } ; [**] => { $ crate :: SyntaxKind :: DOUBLE_STAR } ; [abstract] => { $ crate :: SyntaxKind :: ABSTRACT_KW } ; [async] => { $ crate :: SyntaxKind :: ASYNC_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [final] => { $ crate :: SyntaxKind :: FINAL_KW } ; [is] => { $ crate :: SyntaxKind :: IS_KW } ; [and] => { $ crate :: SyntaxKind :: AND_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [dyn] => { $ crate :: SyntaxKind :: DYN_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [fn] => { $ crate :: SyntaxKind :: FN_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [impl] => { $ crate :: SyntaxKind :: IMPL_KW } ; [import] => { $ crate :: SyntaxKind :: IMPORT_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [missing] => { $ crate :: SyntaxKind :: MISSING_KW } ; [mod] => { $ crate :: SyntaxKind :: MOD_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [not] => { $ crate :: SyntaxKind :: NOT_KW } ; [or] => { $ crate :: SyntaxKind :: OR_KW } ; [package] => { $ crate :: SyntaxKind :: PACKAGE_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [self_type] => { $ crate :: SyntaxKind :: SELF_TYPE_KW } ; [self_value] => { $ crate :: SyntaxKind :: SELF_VALUE_KW } ; [static] => { $ crate :: SyntaxKind :: STATIC_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [super] => { $ crate :: SyntaxKind :: SUPER_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [unsafe] => { $ crate :: SyntaxKind :: UNSAFE_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [yield] => { $ crate :: SyntaxKind :: YIELD_KW } ; [ident] => { $ crate :: SyntaxKind :: IDENTIFIER } ; ['⁽'] => { $ crate :: SyntaxKind :: L_PAREN_SUPERSCRIPT } ; ['⁾'] => { $ crate :: SyntaxKind :: R_PAREN_SUPERSCRIPT } ; }
pub use T;
